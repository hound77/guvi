
                                  All conquered


In a fair there is a game called "All conquered" ,

In which, There are N boxes and you have to start with box 0.  Each box has a distinct number in 0, 1, 2, ..., N-1, and each box may have some access to the next box present. 

NOw, each box i has a list of keys box[i], and each key box[i][j] is an integer in [0, 1, ..., N-1] where N = box.length.  A key box[i][j] = v opens the box with number v.

Initially, all the box start locked (except for box 0). 

You can walk back and forth between boxes freely.

Return true if and only if you can enter every boxes.

Input:
       A vector of vector.
   

input: [[1],[2],[3],[]]

output: true

Explanation:  
We start in box 0, and pick up key 1.
We then go to box 1, and pick up key 2.
We then go to box 2, and pick up key 3.
We then go to box 3.  Since we were able to go to every box, we return true.


Input: [[1,3],[3,0,1],[2],[0]]
Output: false
Explanation: 
We can't enter the box with number 2.




Test Case:


Input: [[1],[],[0,3],[1]]

output: false


Input: [[1,3],[0,2],[2],[4],[1]]

output: true

Input: [[1,4],[],[3,0,4],[2],[]]

output: false


Input: [[]]

output: true

Input: [[1,2,3,4],[],[],[],[]]

output: true



solution:

 void dfs(int start,vector<vector<int>>& boxes,vector<bool> &vis){
        vis[start]=true;
        
        for(auto x : boxes[start]){
            if(!vis[x]){
                dfs(x,boxes,vis);
            }
        }
    }
    
    bool canVisitAllboxes(vector<vector<int>>& boxes) {
        int n = boxes.size();
        vector<bool> vis(n,false);
        dfs(0,boxes,vis);
        for(auto x : vis){
            if(!x) return false;
        }
        return true;
    }




